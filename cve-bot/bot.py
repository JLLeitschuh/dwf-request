#!/usr/bin/env python3

import requests
import os
import re
import tempfile
import git
import json
import datetime

def get_next_cve_path(the_path):
	# Returns the next CVE ID and the path where it should go
	# This needs a lot more intelligence, but it'll be OK for the first pass. There are plenty of integers
	cve_path = None
	the_cve = None

	# Get the current year
	year = str(datetime.datetime.now().year)
	year_dir = os.path.join(the_path, year)

	# Make sure the year directory exists
	if not os.path.exists(year_dir):
		os.mkdir(year_dir)

	# Start looking in directory 1000xxx
	# If that's full, move to 1001xxx
	# We will consider our namespace everything up to 1999999
	for i in range(1000, 2000, 1):
		block_dir = "%sxxx" % i
		block_path = os.path.join(year_dir, block_dir)
		if not os.path.exists(block_path):
			# This is a new path with no files
			os.mkdir(block_path)
			the_cve = "CVE-%s-%s000" % (year, i)
			cve_path = os.path.join(block_path, "%s.json" % the_cve)
			break

		else:
			
			files = os.listdir(block_path)
			files.sort()
			last_file = files[-1]
			id_num = int(last_file.split('.')[0].split('-')[2])
			next_id = id_num + 1
			if next_id % 1000 == 0:
				# It's time to roll over, we'll pick up the ID in the next loop
				continue

			the_cve = "CVE-%s-%s" % (year, next_id)
			cve_path = os.path.join(block_path, "%s.json" % the_cve)
			break

	return (the_cve, cve_path)

def generate_description(issue_data):

	#In [vendor name] [product name] version [version info] a
	#[vulnerability type] exists in the [affected component] that can be
	#attacked via [attack vector] resulting in [impact of exploitation].

	# In [vendor name]
	the_string = "In " + issue_data["vendor_name"] + " "
	# [product name] version
	the_string = the_string + issue_data["product_name"] + " version "
	# [version info] a
	the_string = the_string + issue_data["product_version"] + " a "
	# [vulnerability type] exists in the
	the_string = the_string + issue_data["vulnerability_type"] + " exists in the "
	# [affected component] that can be attacked via
	the_string = the_string + issue_data["affected_component"] + " that can be attacked via "
	# [attack vector] resulting in
	the_string = the_string + issue_data["attack_vector"] + " resulting in "
	# [impact of exploitation].
	#                         ^ Don't forget the punctuation
	the_string = the_string + issue_data["impact"] + "."

	return the_string;

def get_cve_json(cve_id, issue_data):

	# This data format is beyond terrible. Apologies if you found this. I am ashamed for the author of it.
	# We will fix it someday, but not today. The initial goal is to be compatible

	c = {};

	# metadata
	c["data_type"] = "CVE"
	c["data_format"] = "MITRE"
	c["data_version"] = "4.0"
	c["CVE_data_meta"] = {}
	c["CVE_data_meta"]["ASSIGNER"] = "dwf"
	c["CVE_data_meta"]["ID"] = cve_id
	c["CVE_data_meta"]["STATE"] = "PUBLIC"

	# affected
	c["affects"] = {};
	c["affects"]["vendor"] = {}
	c["affects"]["vendor"]["vendor_data"] = []
	c["affects"]["vendor"]["vendor_data"].append({})
	c["affects"]["vendor"]["vendor_data"][0]["vendor_name"] = issue_data["vendor_name"]
	c["affects"]["vendor"]["vendor_data"][0]["product"] = {}
	c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"] = []
	c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"].append({})
	c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["product_name"] = issue_data["product_name"]
	c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["version"] = {}
	c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["version"]["version_data"] = []
	c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["version"]["version_data"].append({})
	# ಠ_ಠ
	c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["version"]["version_data"][0]["version_value"] = issue_data["product_version"]

	# problem
	c["problemtype"] = {}
	c["problemtype"]["problemtype_data"] = []
	c["problemtype"]["problemtype_data"].append({})
	c["problemtype"]["problemtype_data"][0]["description"] = []
	c["problemtype"]["problemtype_data"][0]["description"].append({})
	c["problemtype"]["problemtype_data"][0]["description"][0]["lang"] = "eng"
	c["problemtype"]["problemtype_data"][0]["description"][0]["value"] = issue_data["vulnerability_type"]

	# references
	c["references"] = {}
	c["references"]["reference_data"] = []
	# This will be a loop, we can have multiple references
	for i in issue_data["references"]:
		c["references"]["reference_data"].append({})
		c["references"]["reference_data"][-1]["url"] = i
		c["references"]["reference_data"][-1]["refsource"] = "MISC"
		c["references"]["reference_data"][-1]["name"] = i

	# description
	c["description"] = {}
	c["description"]["description_data"] = []
	c["description"]["description_data"].append({})
	c["description"]["description_data"][0]["lang"] = "eng"
	c["description"]["description_data"][0]["value"] = generate_description(issue_data)

	# DWF namespace
	# If there is any new data to add, do it here. The previous fields should be treated as legacy
	c["dwf"] = issue_data

	return c

def main():

	auth = ('dwfbot', os.environ['GH_TOKEN'])
	params = {
			'accept': "application/vnd.github.v3+json",
			'labels': 'new,check',
			'state': 'open'
	}

	# XXX Get the repo from the environment or something
	resp = requests.get('https://api.github.com/repos/distributedweaknessfiling/test-bot-repo/issues', auth=auth, params=params)
	resp.raise_for_status()

	issues = resp.json()

	if len(issues) == 0:
		# No issues, bail
		os.exit(0)

	for i in issues:
		lines = i['body'].splitlines()
		comments_url = i['comments_url']
		issue_url = i['url']
		issue_title = i['title']
		issue_id = i['number'];	

		if re.search('CVE-\d{4}-\d+', issue_title):
			# There shouldn't be a CVE ID in the title, bail on this issue
			print("Found a CVE in the title for issue %s" % issue_id)
			continue

	
		if (i['user']['login'] != 'dwfbot'):
			print("Issue %s is not owned by me" % issue_id)
			continue

		print("Updating issue %s" % issue_id)

		cve_json = ""
		found_json = False

		for l in lines:
			if l == "--- CVE JSON ---":
				found_json = not found_json
			elif found_json is True:
				cve_json = cve_json + l

		print("JSON to parse: %s" % cve_json)
		cve_data = json.loads(cve_json)

		tmpdir = tempfile.TemporaryDirectory()

		repo = git.Repo.clone_from('https://github.com/distributedweaknessfiling/test-bot-repo.git', tmpdir.name)

		# Check the allowlist
		reporter = cve_data["reporter"]
		allow_list_files = os.path.join(tmpdir.name, "allowlist.json")
		with open(allow_list_files) as json_file:
			allowed_users = json.loads(json_file.read())

		approved_user = False
		if reporter in allowed_users:
			approved_user = True	
		
		(next_cve, next_file) = get_next_cve_path(tmpdir.name)

		new_cve_data = get_cve_json(next_cve, cve_data)
		cve_json = json.dumps(new_cve_data, indent=2)
		cve_json = cve_json + "\n"

		with open(os.path.join(repo.working_dir, next_file), 'w') as json_file:
			json_file.write(cve_json)

		repo.index.add(next_file)
		repo.index.commit("Add %s for #%s" % (next_cve, issue_id))
		repo.remotes.origin.push()

		tmpdir.cleanup()

		# Add a comment to the issue
		body = {
			"body": "This issue has been assigned %s" % next_cve
		}

		headers = {
			"accept": "application/json"
		}

		resp = requests.post(comments_url, json=body, auth=auth, headers=headers)
		resp.raise_for_status()

                # Modify the title and labels
		body = {
			"title": "[%s] %s" % (next_cve, issue_title),
			"labels": ["assigned"]
		}

		if approved_user:
			body["state"] = "closed"

		resp = requests.post(issue_url, json=body, auth=auth, headers=headers)
		resp.raise_for_status()

                # If the issue is a candidate, add the candidate label
	

if __name__ == "__main__":
	main()
