#!/usr/bin/env python3

import requests
import os
import re
import tempfile
import git
import json
import datetime

class Issue:
	def __init__(self, details):

		self.raw_data = details
		self.lines = details['body'].splitlines()
		self.comments_url = details['comments_url']
		self.url = details['url']
		self.title = details['title']
		self.id = details['number'];	
		self.creator = details['user']['login']
		self.auth = ('dwfbot', os.environ['GH_TOKEN'])


	def get_reporter(self):
		data = self.get_cve_json()
		return data['reporter']

	def get_cve_json(self):
		cve_json = ""
		found_json = False

		for l in self.lines:
			if l == "--- CVE JSON ---":
				found_json = not found_json
			elif found_json is True:
				cve_json = cve_json + l

		cve_data = json.loads(cve_json)
		return cve_data

	def add_comment(self, comment):
		body = {
			"body": comment
		}

		headers = {
			"accept": "application/json"
		}

		resp = requests.post(self.comments_url, json=body, auth=self.auth, headers=headers)
		resp.raise_for_status()

	def assign_cve(self, cve_id, approved_user = False):

		# Add a comment to the issue
		self.add_comment("This issue has been assigned %s" % cve_id)

                # Modify the title and labels
		body = {
			"title": "[%s] %s" % (cve_id, self.title),
			"labels": ["assigned"]
		}

		headers = {
			"accept": "application/json"
		}

		if approved_user:
			body["state"] = "closed"
		else:
			# CAN IDs get the candidate label
			body["labels"] = ["assigned", "candidate"]

		resp = requests.post(self.url, json=body, auth=self.auth, headers=headers)
		resp.raise_for_status()

def get_new_issues():
	auth = ('dwfbot', os.environ['GH_TOKEN'])
	params = {
			'accept': "application/vnd.github.v3+json",
			'labels': 'new,check',
			'state': 'open'
	}

	# XXX Get the repo from the environment or something
	resp = requests.get('https://api.github.com/repos/distributedweaknessfiling/test-bot-repo/issues', auth=auth, params=params)
	resp.raise_for_status()

	issues = resp.json()

	to_return = []
	for i in issues:
		to_return.append(Issue(i))

	return to_return

class CVERepo:
	def __init__(self):

		self.tmpdir = tempfile.TemporaryDirectory()
		self.repo = git.Repo.clone_from('https://github.com/distributedweaknessfiling/test-bot-repo.git', self.tmpdir.name)
		allow_list_files = os.path.join(self.tmpdir.name, "allowlist.json")
		with open(allow_list_files) as json_file:
			self.allowed_users = json.loads(json_file.read())

	def approved_user(self, user):
		return user in self.allowed_users

	def add_cve(self, cve_issue):

		cve_data = cve_issue.get_cve_json()

		# Check the allowlist
		reporter = cve_issue.get_reporter()

		approved_user = self.approved_user(reporter)

		(cve_id, cve_path) = self.get_next_cve_path(approved_user)

		new_cve_data = self.get_cve_json_format(cve_id, cve_data)
		cve_json = json.dumps(new_cve_data, indent=2)
		cve_json = cve_json + "\n"

		with open(os.path.join(self.repo.working_dir, cve_path), 'w') as json_file:
			json_file.write(cve_json)

		self.repo.index.add(cve_path)
		self.repo.index.commit("Add %s for #%s" % (cve_id, cve_issue.id))
		self.push()

		return cve_id

	def push(self):
		self.repo.remotes.origin.push()

	def close(self):
		self.tmpdir.cleanup()

	def get_next_cve_path(self, approved_user = False):
		# Returns the next CVE ID and the path where it should go
		# This needs a lot more intelligence, but it'll be OK for the first pass. There are plenty of integers
		cve_path = None
		the_cve = None

		# Get the current year
		year = str(datetime.datetime.now().year)
		year_dir = os.path.join(self.tmpdir.name, year)

		# Make sure the year directory exists
		if not os.path.exists(year_dir):
			os.mkdir(year_dir)

		# Start looking in directory 1000xxx
		# If that's full, move to 1001xxx
		# We will consider our namespace everything up to 1999999
		for i in range(1000, 2000, 1):
			block_dir = "%sxxx" % i
			block_path = os.path.join(year_dir, block_dir)
			if not os.path.exists(block_path):
				# This is a new path with no files
				os.mkdir(block_path)
				the_cve = "CVE-%s-%s000" % (year, i)
				cve_path = os.path.join(block_path, "%s.json" % the_cve)
				if not approved_user:
					the_cve = "CAN-%s-%s000" % (year, i)
				break

			else:
				
				files = os.listdir(block_path)
				files.sort()
				last_file = files[-1]
				id_num = int(last_file.split('.')[0].split('-')[2])
				next_id = id_num + 1
				if next_id % 1000 == 0:
					# It's time to roll over, we'll pick up the ID in the next loop
					continue

				the_cve = "CVE-%s-%s" % (year, next_id)
				cve_path = os.path.join(block_path, "%s.json" % the_cve)
				if not approved_user:
					the_cve = "CAN-%s-%s" % (year, next_id)
				break

		return (the_cve, cve_path)

	def generate_description(self, issue_data):

		#In [vendor name] [product name] version [version info] a
		#[vulnerability type] exists in the [affected component] that can be
		#attacked via [attack vector] resulting in [impact of exploitation].

		# In [vendor name]
		the_string = "In " + issue_data["vendor_name"] + " "
		# [product name] version
		the_string = the_string + issue_data["product_name"] + " version "
		# [version info] a
		the_string = the_string + issue_data["product_version"] + " a "
		# [vulnerability type] exists in the
		the_string = the_string + issue_data["vulnerability_type"] + " exists in the "
		# [affected component] that can be attacked via
		the_string = the_string + issue_data["affected_component"] + " that can be attacked via "
		# [attack vector] resulting in
		the_string = the_string + issue_data["attack_vector"] + " resulting in "
		# [impact of exploitation].
		#                         ^ Don't forget the punctuation
		the_string = the_string + issue_data["impact"] + "."

		return the_string;

	def get_cve_json_format(self, cve_id, issue_data):

		# This data format is beyond terrible. Apologies if you found this. I am ashamed for the author of it.
		# We will fix it someday, but not today. The initial goal is to be compatible

		c = {};

		# metadata
			# Or CAN
		if cve_id.startswith("CVE"):
			c["data_type"] = "CVE"
		else:
			c["data_type"] = "CAN"
		c["data_format"] = "MITRE"
		c["data_version"] = "4.0"
		c["CVE_data_meta"] = {}
		c["CVE_data_meta"]["ASSIGNER"] = "dwf"
			# CAN ID
		c["CVE_data_meta"]["ID"] = cve_id
		c["CVE_data_meta"]["STATE"] = "PUBLIC"

		# affected
		c["affects"] = {};
		c["affects"]["vendor"] = {}
		c["affects"]["vendor"]["vendor_data"] = []
		c["affects"]["vendor"]["vendor_data"].append({})
		c["affects"]["vendor"]["vendor_data"][0]["vendor_name"] = issue_data["vendor_name"]
		c["affects"]["vendor"]["vendor_data"][0]["product"] = {}
		c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"] = []
		c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"].append({})
		c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["product_name"] = issue_data["product_name"]
		c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["version"] = {}
		c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["version"]["version_data"] = []
		c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["version"]["version_data"].append({})
		# ಠ_ಠ
		c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["version"]["version_data"][0]["version_value"] = issue_data["product_version"]

		# problem
		c["problemtype"] = {}
		c["problemtype"]["problemtype_data"] = []
		c["problemtype"]["problemtype_data"].append({})
		c["problemtype"]["problemtype_data"][0]["description"] = []
		c["problemtype"]["problemtype_data"][0]["description"].append({})
		c["problemtype"]["problemtype_data"][0]["description"][0]["lang"] = "eng"
		c["problemtype"]["problemtype_data"][0]["description"][0]["value"] = issue_data["vulnerability_type"]

		# references
		c["references"] = {}
		c["references"]["reference_data"] = []
		# This will be a loop, we can have multiple references
		for i in issue_data["references"]:
			c["references"]["reference_data"].append({})
			c["references"]["reference_data"][-1]["url"] = i
			c["references"]["reference_data"][-1]["refsource"] = "MISC"
			c["references"]["reference_data"][-1]["name"] = i

		# description
		c["description"] = {}
		c["description"]["description_data"] = []
		c["description"]["description_data"].append({})
		c["description"]["description_data"][0]["lang"] = "eng"
		c["description"]["description_data"][0]["value"] = self.generate_description(issue_data)

		# DWF namespace
		# If there is any new data to add, do it here. The previous fields should be treated as legacy
		c["dwf"] = issue_data

		return c

def main():

	# Look for new issues
	for i in get_new_issues():

		if re.search('(CVE|CAN)-\d{4}-\d+', i.title):
			# There shouldn't be a CVE/CAN ID in the title, bail on this issue
			print("Found an ID in the title for issue %s" % i.id)
			continue
	
		if (i.creator != 'dwfbot'):
			print("Issue %s is not created by dwfbot" % i.id)
			continue

		print("Updating issue %s" % i.id)
		cve_repo = CVERepo()
		cve_id = cve_repo.add_cve(i)
		i.assign_cve(cve_id, cve_repo.approved_user(i.get_reporter()))

	# Now look for approved CAN issues
#	issues = get_approved_can_issues()
#	for i in issues:
#		approver = i.who_approved():
	

if __name__ == "__main__":
	main()
