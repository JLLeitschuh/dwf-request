#!/usr/bin/env python3

import requests
import os
import re
import tempfile
import git
import json
import datetime

class Issue:
	def __init__(self, details):

		self.raw_data = details
		self.lines = details['body'].splitlines()
		self.comments_url = details['comments_url']
		self.events_url = details['events_url']
		self.url = details['url']
		self.title = details['title']
		self.id = details['number'];	
		self.creator = details['user']['login']
		self.auth = ('dwfbot', os.environ['GH_TOKEN'])

	def get_cve_id(self):
		# We are going to only trust the comment from dwfbot for this
		# ID. It's the most trustworthy ID

		comments = self.get_comments()
		comments.reverse()
		for i in comments:
			if i['user']['login'] == 'dwfbot':
				if i['body'].startswith('This issue has been assigned'):
					match = re.search('((CVE|CAN)-\d{4}-\d+)', i['body'])	
					cve_id = match.groups()[0]
					return cve_id	
		return None

	def get_events(self):

		events = []
		page = 0
		while(True):
			params = {
					'per_page': 100,
					'page': page
			}
			resp = requests.get(self.events_url, auth=self.auth, params=params)
			resp.raise_for_status()
			if len(resp.json()) == 0:
				break
			else:
				page = page + 1
				events.extend(resp.json())

		return events

	def get_comments(self):
		comments = []
		page = 0
		while(True):
			params = {
					'per_page': 100,
					'page': page
			}
			resp = requests.get(self.comments_url, auth=self.auth, params=params)
			resp.raise_for_status()
			if len(resp.json()) == 0:
				break
			else:
				page = page + 1
				comments.extend(resp.json())

		return comments

	def who_approved(self):
		events = self.get_events()
		# We should reverse the list as we want to figure out who gave the last approval
		events.reverse()
		for i in events:
			# I'm pretty sure we need better logic here
			if i['event'] == 'labeled' and i['label']['name'] == 'approved':
				approver = i['actor']['login']
				return approver
				

	def get_reporter(self):
		data = self.get_cve_json()
		return data['reporter']

	def get_cve_json(self):
		cve_json = ""
		found_json = False

		for l in self.lines:
			if l == "--- CVE JSON ---":
				found_json = not found_json
			elif found_json is True:
				cve_json = cve_json + l

		cve_data = json.loads(cve_json)
		return cve_data

	def add_comment(self, comment):
		body = {
			"body": comment
		}

		headers = {
			"accept": "application/json"
		}

		resp = requests.post(self.comments_url, json=body, auth=self.auth, headers=headers)
		resp.raise_for_status()

	def can_to_cve(self):
		can_id = self.get_cve_id()
		# Make sure the ID starts with CAN
		if not can_id.startswith('CAN-'):
			return None

		# Get the path to the file
		year = can_id.split('-')[1]
		id_str = can_id.split('-')[2]
		cve_id = "CVE-%s-%s" % (year, id_str)

		self.title = self.title.replace(can_id, cve_id)		
		body = {
			"title": self.title,
			"state": "closed"
		}
		headers = {
			"accept": "application/json"
		}
		resp = requests.post(self.url, json=body, auth=self.auth, headers=headers)
		resp.raise_for_status()

	def assign_cve(self, cve_id, approved_user = False):

		# Add a comment to the issue
		self.add_comment("This issue has been assigned %s" % cve_id)

                # Modify the title and labels
		body = {
			"title": "[%s] %s" % (cve_id, self.title),
			"labels": ["assigned"]
		}

		headers = {
			"accept": "application/json"
		}

		if approved_user:
			body["state"] = "closed"
		else:
			# CAN IDs get the candidate label
			body["labels"] = ["assigned", "candidate"]

		resp = requests.post(self.url, json=body, auth=self.auth, headers=headers)
		resp.raise_for_status()

def get_new_issues():
	auth = ('dwfbot', os.environ['GH_TOKEN'])
	params = {
			'accept': "application/vnd.github.v3+json",
			'labels': 'new,check',
			'state': 'open'
	}

	# XXX Get the repo from the environment or something
	resp = requests.get('https://api.github.com/repos/distributedweaknessfiling/dwflist/issues', auth=auth, params=params)
	resp.raise_for_status()

	issues = resp.json()

	to_return = []
	for i in issues:
		to_return.append(Issue(i))

	return to_return

def get_approved_can_issues():
	auth = ('dwfbot', os.environ['GH_TOKEN'])
	params = {
			'accept': "application/vnd.github.v3+json",
			'labels': 'approved',
			'state': 'open'
	}

	# XXX Get the repo from the environment or something
	resp = requests.get('https://api.github.com/repos/distributedweaknessfiling/dwflist/issues', auth=auth, params=params)
	resp.raise_for_status()

	issues = resp.json()

	to_return = []
	for i in issues:
		to_return.append(Issue(i))

	return to_return

class CVERepo:
	def __init__(self):

		self.tmpdir = tempfile.TemporaryDirectory()
		self.repo = git.Repo.clone_from('https://github.com/distributedweaknessfiling/dwflist.git', self.tmpdir.name)
		allow_list_files = os.path.join(self.tmpdir.name, "allowlist.json")
		with open(allow_list_files) as json_file:
			self.allowed_users = json.loads(json_file.read())

	def approved_user(self, user):
		return user in self.allowed_users

	def can_to_cve(self, cve_issue):

		can_id = cve_issue.get_cve_id()
		# Make sure the ID starts with CAN
		if not can_id.startswith('CAN-'):
			return None

		# Get the path to the file
		year = can_id.split('-')[1]
		id_str = can_id.split('-')[2]
		namespace = "%sxxx" % id_str[0:-3]
		cve_id = "CVE-%s-%s" % (year, id_str)
		filename = "%s.json" % (cve_id)

		can_file = os.path.join(year, namespace, filename)
		git_file = os.path.join(self.repo.working_dir, can_file)
		
		# Open the file
		with open(git_file) as json_file:
				# Read the json
				can_data = json.loads(json_file.read())

		# Swap the CAN to CVE
		can_data['data_type'] = 'CVE'
		can_data['CVE_data_meta']['ID'] = cve_id

		cve_json = json.dumps(can_data, indent=2)
		cve_json = cve_json + "\n"
		# save the json
		with open(git_file, 'w') as json_file:
			json_file.write(cve_json)

		# Commit the file
		self.repo.index.add(can_file)
		self.repo.index.commit("Promoted to %s for #%s" % (cve_id, cve_issue.id))
		self.push()

	def add_cve(self, cve_issue):

		cve_data = cve_issue.get_cve_json()

		# Check the allowlist
		reporter = cve_issue.get_reporter()

		approved_user = self.approved_user(reporter)

		(cve_id, cve_path) = self.get_next_cve_path(approved_user)

		new_cve_data = self.get_cve_json_format(cve_id, cve_data)
		cve_json = json.dumps(new_cve_data, indent=2)
		cve_json = cve_json + "\n"

		with open(os.path.join(self.repo.working_dir, cve_path), 'w') as json_file:
			json_file.write(cve_json)

		self.repo.index.add(cve_path)
		self.repo.index.commit("Add %s for #%s" % (cve_id, cve_issue.id))
		self.push()

		return cve_id

	def push(self):
		self.repo.remotes.origin.push()

	def close(self):
		self.tmpdir.cleanup()

	def get_next_cve_path(self, approved_user = False):
		# Returns the next CVE ID and the path where it should go
		# This needs a lot more intelligence, but it'll be OK for the first pass. There are plenty of integers
		cve_path = None
		the_cve = None

		# Get the current year
		year = str(datetime.datetime.now().year)
		year_dir = os.path.join(self.tmpdir.name, year)

		# Make sure the year directory exists
		if not os.path.exists(year_dir):
			os.mkdir(year_dir)

		# Start looking in directory 1000xxx
		# If that's full, move to 1001xxx
		# We will consider our namespace everything up to 1999999
		for i in range(1000, 2000, 1):
			block_dir = "%sxxx" % i
			block_path = os.path.join(year_dir, block_dir)
			if not os.path.exists(block_path):
				# This is a new path with no files
				os.mkdir(block_path)
				the_cve = "CVE-%s-%s000" % (year, i)
				cve_path = os.path.join(block_path, "%s.json" % the_cve)
				if not approved_user:
					the_cve = "CAN-%s-%s000" % (year, i)
				break

			else:
				
				files = os.listdir(block_path)
				files.sort()
				last_file = files[-1]
				id_num = int(last_file.split('.')[0].split('-')[2])
				next_id = id_num + 1
				if next_id % 1000 == 0:
					# It's time to roll over, we'll pick up the ID in the next loop
					continue

				the_cve = "CVE-%s-%s" % (year, next_id)
				cve_path = os.path.join(block_path, "%s.json" % the_cve)
				if not approved_user:
					the_cve = "CAN-%s-%s" % (year, next_id)
				break

		return (the_cve, cve_path)

	def generate_description(self, issue_data):

		#In [vendor name] [product name] version [version info] a
		#[vulnerability type] exists in the [affected component] that can be
		#attacked via [attack vector] resulting in [impact of exploitation].

		# In [vendor name]
		the_string = "In " + issue_data["vendor_name"] + " "
		# [product name] version
		the_string = the_string + issue_data["product_name"] + " version "
		# [version info] a
		the_string = the_string + issue_data["product_version"] + " a "
		# [vulnerability type] exists in the
		the_string = the_string + issue_data["vulnerability_type"] + " exists in the "
		# [affected component] that can be attacked via
		the_string = the_string + issue_data["affected_component"] + " that can be attacked via "
		# [attack vector] resulting in
		the_string = the_string + issue_data["attack_vector"] + " resulting in "
		# [impact of exploitation].
		#                         ^ Don't forget the punctuation
		the_string = the_string + issue_data["impact"] + "."

		return the_string;

	def get_cve_json_format(self, cve_id, issue_data):

		# This data format is beyond terrible. Apologies if you found this. I am ashamed for the author of it.
		# We will fix it someday, but not today. The initial goal is to be compatible

		c = {};

		# metadata
			# Or CAN
		if cve_id.startswith("CVE"):
			c["data_type"] = "CVE"
		else:
			c["data_type"] = "CAN"
		c["data_format"] = "MITRE"
		c["data_version"] = "4.0"
		c["CVE_data_meta"] = {}
		c["CVE_data_meta"]["ASSIGNER"] = "dwf"
			# CAN ID
		c["CVE_data_meta"]["ID"] = cve_id
		c["CVE_data_meta"]["STATE"] = "PUBLIC"

		# affected
		c["affects"] = {};
		c["affects"]["vendor"] = {}
		c["affects"]["vendor"]["vendor_data"] = []
		c["affects"]["vendor"]["vendor_data"].append({})
		c["affects"]["vendor"]["vendor_data"][0]["vendor_name"] = issue_data["vendor_name"]
		c["affects"]["vendor"]["vendor_data"][0]["product"] = {}
		c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"] = []
		c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"].append({})
		c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["product_name"] = issue_data["product_name"]
		c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["version"] = {}
		c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["version"]["version_data"] = []
		c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["version"]["version_data"].append({})
		# ಠ_ಠ
		c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["version"]["version_data"][0]["version_value"] = issue_data["product_version"]

		# problem
		c["problemtype"] = {}
		c["problemtype"]["problemtype_data"] = []
		c["problemtype"]["problemtype_data"].append({})
		c["problemtype"]["problemtype_data"][0]["description"] = []
		c["problemtype"]["problemtype_data"][0]["description"].append({})
		c["problemtype"]["problemtype_data"][0]["description"][0]["lang"] = "eng"
		c["problemtype"]["problemtype_data"][0]["description"][0]["value"] = issue_data["vulnerability_type"]

		# references
		c["references"] = {}
		c["references"]["reference_data"] = []
		# This will be a loop, we can have multiple references
		for i in issue_data["references"]:
			c["references"]["reference_data"].append({})
			c["references"]["reference_data"][-1]["url"] = i
			c["references"]["reference_data"][-1]["refsource"] = "MISC"
			c["references"]["reference_data"][-1]["name"] = i

		# description
		c["description"] = {}
		c["description"]["description_data"] = []
		c["description"]["description_data"].append({})
		c["description"]["description_data"][0]["lang"] = "eng"
		c["description"]["description_data"][0]["value"] = self.generate_description(issue_data)

		# DWF namespace
		# If there is any new data to add, do it here. The previous fields should be treated as legacy
		c["dwf"] = issue_data

		return c

def main():

	print(datetime.datetime.now().isoformat())
	cve_repo = CVERepo()

	# Look for new issues
	for i in get_new_issues():

		if re.search('(CVE|CAN)-\d{4}-\d+', i.title):
			# There shouldn't be a CVE/CAN ID in the title, bail on this issue
			print("Found an ID in the title for issue %s" % i.id)
			continue
	
		if (i.creator != 'dwfbot'):
			print("Issue %s is not created by dwfbot" % i.id)
			continue

		print("Updating issue %s" % i.id)
		cve_id = cve_repo.add_cve(i)
		i.assign_cve(cve_id, cve_repo.approved_user(i.get_reporter()))

	# Now look for approved CAN issues
	issues = get_approved_can_issues()
	for i in issues:
		approver = i.who_approved()
		if cve_repo.approved_user(approver):
			# Flip this to a CVE
			cve_repo.can_to_cve(i)
			i.can_to_cve()
		else:
			print("%s is unapproved for %s" % (approver, i.id))

	cve_repo.close()
	
if __name__ == "__main__":
	main()
