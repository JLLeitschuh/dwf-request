
// require the library, main export is a function
const simpleGit = require('simple-git');
const fs = require('fs');
const tmp = require('tmp');
const axios = require('axios');


function generate_description(issue_data) {

	//In [vendor name] [product name] version [version info] a
	//[vulnerability type] exists in the [affected component] that can be
	//attacked via [attack vector] resulting in [impact of exploitation].

	// In [vendor name]
	the_string = "In " + issue_data["vendor_name"] + " ";
	// [product name] version
	the_string = the_string + issue_data["product_name"] + " version ";
	// [version info] a
	the_string = the_string + issue_data["product_version"] + " a ";
	// [vulnerability type] exists in the
	the_string = the_string + issue_data["vulnerability_type"] + " exists in the ";
	// [affected component] that can be attacked via
	the_string = the_string + issue_data["affected_component"] + " that can be attacked via ";
	// [attack vector] resulting in
	the_string = the_string + issue_data["attack_vector"] + " resulting in ";
	// [impact of exploitation].
	//                         ^ Don't forget the punctuation
	the_string = the_string + issue_data["impact"] + ".";

	return the_string;
}

function get_cve_json(id, issue_data) {

	// This data format is beyond terrible. Apologies if you found this. I am ashamed for the author of it.
	// We will fix it someday, but not today.

	c = {};

	// metadata
	c["data_type"] = "CVE";
	c["data_format"] = "MITRE";
	c["data_version"] = "4.0";
	c["CVE_data_meta"] = {};
	c["CVE_data_meta"]["ASSIGNER"] = "dwf";
	c["CVE_data_meta"]["ID"] = id;
	c["CVE_data_meta"]["STATE"] = "PUBLIC";

	// affected
	c["affects"] = {};
	c["affects"]["vendor"] = {}
	c["affects"]["vendor"]["vendor_data"] = [];
	c["affects"]["vendor"]["vendor_data"][0] = {};
	c["affects"]["vendor"]["vendor_data"][0]["vendor_name"] = issue_data["vendor_name"];
	c["affects"]["vendor"]["vendor_data"][0]["product"] = {};
	c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"] = [];
	c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0] = {};
	c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["product_name"] = issue_data["product_name"];
	c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["version"] = {};
	c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["version"]["version_data"] = [];
	c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["version"]["version_data"][0] = {};
	c["affects"]["vendor"]["vendor_data"][0]["product"]["product_data"][0]["version"]["version_data"][0]["version_value"] = issue_data["product_version"];

	// problem
	c["problemtype"] = {};
	c["problemtype"]["problemtype_data"] = [];
	c["problemtype"]["problemtype_data"][0] = {};
	c["problemtype"]["problemtype_data"][0]["description"] = [];
	c["problemtype"]["problemtype_data"][0]["description"][0] = {};
	c["problemtype"]["problemtype_data"][0]["description"][0]["lang"] = "eng";
	c["problemtype"]["problemtype_data"][0]["description"][0]["value"] = issue_data["vulnerability_type"];

	// references
	c["references"] = {};
	c["references"]["reference_data"] = [];
	// This will be a loop, we can have multiple references
	c["references"]["reference_data"][0] = {};
	c["references"]["reference_data"][0]["url"] = issue_data["references"];
	c["references"]["reference_data"][0]["refsource"] = "MISC";
	c["references"]["reference_data"][0]["name"] = issue_data["references"];

	// description
	c["description"] = {};
	c["description"]["description_data"] = [];
	c["description"]["description_data"][0] = {};
	c["description"]["description_data"][0]["lang"] = "eng";
	c["description"]["description_data"][0]["value"] = generate_description(issue_data);

	// DWF namespace
	c["dwf"] = issue_data;
	

	return c;
}

async function main() {

	var issues = [];
	// Get all new issues
	// XXX paginate this

        var opts = {
                auth: {
                        username: 'dwfbot',
                        password: process.env.GH_TOKEN,
                },
		params: {
			accept: "application/vnd.github.v3+json",
			labels: 'new,check',
			state: 'open'
		}
        };
        try {
                var resp = await axios.get(`https://api.github.com/repos/distributedweaknessfiling/test-bot-repo/issues`, opts);    
		issues = resp['data']


        } catch(err) {
		console.log("A bad thing happened");
                console.log(err);
                throw err;
        }

	// If there are new issues

	if (issues.length == 0) {
		// If there are no issues, just bail
		return;
	}

	// Extract CVE json details

	for (var i in issues) {

		var lines = issues[i]['body'].split(/\r\n|\n|\r/);
		var comments_url = issues[i]['comments_url'];
		var issue_url = issues[i]['url'];
		var issue_title = issues[i]['title'];
		var issue_id = issues[i]['number'];

		// See if the title has a CVE in it, if so, something very bad happened
		if (issue_title.match(/CVE-\d{4}-\d+/)) {
			console.log(`Issue ${issue_id} seems to have a CVE ID`);
			continue;
		}

		if (issues[i]['user']['login'] != 'dwfbot') {
			console.log(`Issue ${issue_id} is not owned by me`);
			continue;
		}

		console.log(`Updating issue ${issue_id}`);

		var cve_json = ""
		var found_json = false;

		for (var l in lines) {
			if (lines[l] == "--- CVE JSON ---") {
				if (found_json == true) {
					found_json = false;
				} else {
					found_json = true;
				}
			} else if (found_json == true) {
				cve_json = cve_json + lines[l];
			}
		}
		console.log(`JSON to write ${cve_json}`);

		// Checkout CVE repo

		var tmpObj = tmp.dirSync({unsafeCleanup: true});
		var tmpDir = tmpObj.name;

		var git = simpleGit();
		await git.clone('https://github.com/distributedweaknessfiling/test-bot-repo.git', tmpDir)

		var gitrepo = simpleGit(tmpDir);
		process.chdir(tmpDir);

		// Get the next CVE ID

		var files = fs.readdirSync('2021');
		files.sort();
		var last_file = files[files.length - 1];
		id_num = Number((last_file.split('.')[0]).split('-')[2]);
		next_id = id_num + 1;
		next_cve = `CVE-2021-${next_id}`;
		next_file = `2021/CVE-2021-${next_id}.json`;

		// Write CVE json to CVE file

		// Turn the json string into data, process it, then back to json
		// so we can format it pretty
		var cve_data = JSON.parse(cve_json);
		var new_cve_data = get_cve_json(next_cve, cve_data);
		var json_data = JSON.stringify(new_cve_data, null, '  ');
		// Add a newline at the end
		json_data = json_data + "\n";

		fs.writeFileSync(next_file, json_data);

		// Commit file
		await gitrepo.add(next_file);
		await gitrepo.commit(`Add ${next_cve} for #${issue_id}`);
		await gitrepo.push();

		tmpObj.removeCallback();

		// Update the issue summary, add a comment, and remove label
		var body = {
			body: `This issue has been assigned ${next_cve}`,
		};
		var opts = {
			headers: { accept: 'application/json' },
			auth: {
				username: 'dwfbot',
				password: process.env.GH_TOKEN,
			}
		};
		try {
			var resp = await axios.post(comments_url, body, opts);    

		} catch(err) {
			console.log("A bad thing happened");
			console.log(err);
			throw err;
		}

		// Modify the title and labels
		var body = {
			title: `[${next_cve}] ${issue_title}`,
			labels: ['assigned']
		};
		var opts = {
			headers: { accept: 'application/json' },
			auth: {
				username: 'dwfbot',
				password: process.env.GH_TOKEN,
			}
		};
		try {
			var resp = await axios.patch(issue_url, body, opts);    

		} catch(err) {
			console.log("A bad thing happened");
			console.log(err);
			throw err;
		}
		// If the issue is a candidate, add the candidate label
	}

}

if (require.main === module) {
  main();
}
